package frc.robot.subsystems;

import edu.wpi.first.wpilibj.Joystick;
//import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

import com.revrobotics.spark.SparkBase.PersistMode;
import com.revrobotics.spark.SparkBase.ResetMode;
//import com.ctre.phoenix.motorcontrol.can.BaseMotorController;
/*import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.ControlMode;*/
import com.revrobotics.spark.SparkMax;
import com.revrobotics.spark.config.SparkMaxConfig;
import com.revrobotics.spark.config.SparkBaseConfig.IdleMode;
import com.revrobotics.spark.config.SparkBaseConfig.*;

import frc.robot.interfaces.*;
//import frc.robot.RobotContainer;
//import frc.robot.Ports;


/**
 * The {@code Shooter} class contains fields and methods pertaining to the function of the roller.
 */
public class SimpleShooter extends SubsystemBase implements ISimpleShooter{
	/**
	 * 
	 */
	static final double MAX_PCT_OUTPUT = 1.0;
	static final double ALMOST_MAX_PCT_OUTPUT = 1.0;
	static final double HALF_PCT_OUTPUT = 0.5;
	static final double REDUCED_PCT_OUTPUT = 0.85;
	//todo fix
	
	static final int WAIT_MS = 1000;
	static final int TIMEOUT_MS = 5000;

	static final int SPARKMAX_TIMEOUT_MS = 20;

	static final int ROLL_DISTANCE_INCHES = 13;
	//static final int RELEASE_DISTANCE_INCHES = 17;
	static final int SHOOT_DISTANCE_INCHES = 17;
	
	SparkMax shooter;
	SparkMax shooter_follower;
	SparkMaxConfig shooterConfig;
	SparkMaxConfig shooterFollowerConfig;
		
	boolean isTaking;
	boolean isShooting;
	
		
	public SimpleShooter(SparkMax shooter_in, SparkMax shooter_follower_in) {
		
		shooter = shooter_in;
		shooter_follower = shooter_follower_in;
		shooterConfig = new SparkMaxConfig();
		shooterFollowerConfig = new SparkMaxConfig();

		shooterConfig
			.inverted(false)
			.idleMode(IdleMode.kCoast);

		shooterFollowerConfig
			.inverted(false)
			.idleMode(IdleMode.kCoast);
		// Mode of operation during Neutral output may be set by using the setNeutralMode() function.
		// As of right now, there are two options when setting the neutral mode of a motor controller,
		// brake and coast.
		// Motor controller output direction can be set by calling the setInverted() function as seen below.
		// Note: Regardless of invert value, the LEDs will blink green when positive output is requested (by robot code or firmware closed loop).
		// Only the motor leads are inverted. This feature ensures that sensor phase and limit switches will properly match the LED pattern
		// (when LEDs are green => forward limit switch and soft limits are being checked).

		// Both the Talon SRX and Victor SPX have a follower feature that allows the motor controllers to mimic another motor controller's output.
		// Users will still need to set the motor controller's direction, and neutral mode.
		// The method follow() allows users to create a motor controller follower of not only the same model, but also other models
		// , talon to talon, victor to victor, talon to victor, and victor to talon.
		shooterFollowerConfig.follow(shooter);


		// Motor controllers that are followers can set Status 1 and Status 2 to 255ms(max) using setStatusFramePeriod.
		// The Follower relies on the master status frame allowing its status frame to be slowed without affecting performance.
		// This is a useful optimization to manage CAN bus utilization.
		/*shooter_follower.setStatusFramePeriod(StatusFrame.Status_1_General, 255, SPARKMAX_TIMEOUT_MS);
		shooter_follower.setStatusFramePeriod(StatusFrame.Status_2_Feedback0, 255, SPARKMAX_TIMEOUT_MS);

		setPIDParameters();*/

		// set peak output to max in case if had been reduced previously
		//setNominalAndPeakOutputs(MAX_PCT_OUTPUT);
		//TODO empty method

		shooter.configure(shooterConfig, ResetMode.kResetSafeParameters, PersistMode.kPersistParameters);
		shooter_follower.configure(shooterFollowerConfig, ResetMode.kResetSafeParameters, PersistMode.kPersistParameters);
	}
	
	/*@Override
	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		setDefaultCommand(new ShooterStop());
	}*/

	@Override
	public void periodic() {
		// Put code here to be run every loop

	}

	public void take() {
		//SwitchedCamera.setUsbCamera(Ports.UsbCamera.GRASPER_CAMERA);

		shooter.set(REDUCED_PCT_OUTPUT);
		
		isTaking = true;
		isShooting = false;
	}
	
	/*public void release() {
		//SwitchedCamera.setUsbCamera(Ports.UsbCamera.GRASPER_CAMERA);

		shooter.set(-ALMOST_MAX_PCT_OUTPUT);
		
		isReleasing = true;
		isTaking = false;
		isShooting = false;
	}*/

	public void shoot() {
		//SwitchedCamera.setUsbCamera(Ports.UsbCamera.GRASPER_CAMERA);

		shooter.set(-MAX_PCT_OUTPUT);
		
		isTaking = false;
		isShooting = true;
	}
	
	
	public void stop() {
		shooter.set(0);
		
		isTaking = false;
		isShooting = false;
	}
	
		
	// NOTE THAT THIS METHOD WILL IMPACT BOTH OPEN AND CLOSED LOOP MODES
	public void setNominalAndPeakOutputs(double peakOutput)
	{
		/*roller.configPeakOutputForward(peakOutput, SPARKMAX_TIMEOUT_MS);
		roller.configPeakOutputReverse(-peakOutput, SPARKMAX_TIMEOUT_MS);

		roller.configNominalOutputForward(0, SPARKMAX_TIMEOUT_MS);
		roller.configNominalOutputReverse(0, SPARKMAX_TIMEOUT_MS);*/
	}
	
	public boolean isTaking(){
		return isTaking;
	}
	
	/*public boolean isReleasing(){
		return isReleasing;
	}*/

	public boolean isShooting(){
		return isShooting;
	}

	// for debug purpose only
	public void joystickControl(Joystick joystick)
	{
		shooter.set(joystick.getY());
	}

	
}










